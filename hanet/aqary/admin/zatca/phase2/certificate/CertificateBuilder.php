<?php
/**
 * ZATCA Certificate Builder
 *
 * Generates CSR (Certificate Signing Request) for ZATCA
 *
 * @charset UTF-8
 * @version 2.0
 * @date 2025-11-01
 */

require_once __DIR__ . '/../../config/phase2_config.php';

class CertificateBuilder {

    private $config;
    private $privateKey;
    private $csr;

    /**
     * Constructor
     */
    public function __construct() {
        // Base configuration - ZATCA REQUIRES ECDSA secp256k1, NOT RSA!
        $this->config = [
            'digest_alg' => 'sha256',
            'private_key_type' => OPENSSL_KEYTYPE_EC,
            'curve_name' => 'secp256k1',  // ZATCA required curve
            'encrypt_key' => false
        ];

        // Add OpenSSL config path for Windows compatibility
        $opensslConfig = $this->findOpenSSLConfig();
        if ($opensslConfig) {
            $this->config['config'] = $opensslConfig;
        } else {
            // Create a temporary config file
            $this->config['config'] = $this->createTempOpenSSLConfig();
        }
    }

    /**
     * Find OpenSSL configuration file
     *
     * @return string|null Path to openssl.cnf or null if not found
     */
    private function findOpenSSLConfig() {
        // Common paths for OpenSSL config on Windows
    $possiblePaths = [
        '../../../../../../aso/Apache24/php-8.5.0-Win32-vs17-x64/extras/ssl/openssl.cnf',
        '../../../../../../aso/Apache24/extras/ssl/openssl.cnf',
        '../../../../OpenSSL-Win64/bin/openssl/openssl.exe',
        'C:/saudiakar-erp/hanet/aqary/OpenSSL-Win64/bin/openssl.exe',
        '../../../../OpenSSL-Win64/bin/openssl.exe',
        '../../../../../OpenSSL-Win64/bin/openssl.exe',
        'C:/wamp/bin/apache/apache2.4.46/conf/openssl.cnf',
        'C:/wamp64/bin/apache/apache2.4.46/conf/openssl.cnf',
        'C:/php/extras/openssl/openssl.cnf',
        getenv('OPENSSL_CONF'),
        dirname(php_ini_loaded_file()) . '/extras/openssl/openssl.cnf',
    ];

        foreach ($possiblePaths as $path) {
            if ($path && file_exists($path)) {
                ZatcaPhase2Config::log("Found OpenSSL config at: $path", 'INFO');
                return $path;
            }
        }

        return null;
    }

    /**
     * Create a temporary OpenSSL configuration file
     *
     * @return string Path to the temporary config file
     */
    private function createTempOpenSSLConfig() {
        $tempDir = sys_get_temp_dir();
        $configPath = $tempDir . '/zatca_openssl.cnf';

        $configContent = <<<EOT
# Temporary OpenSSL Configuration for ZATCA
# Generated by CertificateBuilder

HOME            = .
RANDFILE        = \$ENV::HOME/.rnd

[ ca ]
default_ca      = CA_default

[ CA_default ]
dir             = ./demoCA
certs           = \$dir/certs
crl_dir         = \$dir/crl
database        = \$dir/index.txt
new_certs_dir   = \$dir/newcerts
certificate     = \$dir/cacert.pem
serial          = \$dir/serial
crlnumber       = \$dir/crlnumber
crl             = \$dir/crl.pem
private_key     = \$dir/private/cakey.pem
RANDFILE        = \$dir/private/.rand
x509_extensions = usr_cert
name_opt        = ca_default
cert_opt        = ca_default
default_days    = 365
default_crl_days= 30
default_md      = sha256
preserve        = no
policy          = policy_match

[ policy_match ]
countryName             = match
stateOrProvinceName     = optional
organizationName        = optional
organizationalUnitName  = optional
commonName              = supplied
emailAddress            = optional

[ req ]
default_bits        = 256
default_keyfile     = privkey.pem
distinguished_name  = req_distinguished_name
attributes          = req_attributes
x509_extensions     = v3_ca
string_mask         = utf8only
req_extensions      = v3_req
# ZATCA requires ECDSA with secp256k1 curve
default_md          = sha256

[ req_distinguished_name ]
countryName                     = Country Name (2 letter code)
countryName_default             = SA
countryName_min                 = 2
countryName_max                 = 2
stateOrProvinceName             = State or Province Name (full name)
stateOrProvinceName_default     = Riyadh
localityName                    = Locality Name (eg, city)
0.organizationName              = Organization Name (eg, company)
0.organizationName_default      = Your Company
organizationalUnitName          = Organizational Unit Name (eg, section)
commonName                      = Common Name (e.g. server FQDN or YOUR name)
commonName_max                  = 64
emailAddress                    = Email Address
emailAddress_max                = 64

[ req_attributes ]
challengePassword               = A challenge password
challengePassword_min           = 4
challengePassword_max           = 20
unstructuredName                = An optional company name

[ usr_cert ]
basicConstraints=CA:FALSE
nsComment                       = "OpenSSL Generated Certificate"
subjectKeyIdentifier=hash
authorityKeyIdentifier=keyid,issuer

[ v3_req ]
basicConstraints = CA:FALSE
keyUsage = nonRepudiation, digitalSignature, keyEncipherment

[ v3_ca ]
subjectKeyIdentifier=hash
authorityKeyIdentifier=keyid:always,issuer
basicConstraints = CA:true

[ crl_ext ]
authorityKeyIdentifier=keyid:always

[ proxy_cert_ext ]
basicConstraints=CA:FALSE
nsComment                       = "OpenSSL Generated Certificate"
subjectKeyIdentifier=hash
authorityKeyIdentifier=keyid,issuer
proxyCertInfo=critical,language:id-ppl-anyLanguage,pathlen:3,policy:foo

EOT;

        file_put_contents($configPath, $configContent);
        ZatcaPhase2Config::log("Created temporary OpenSSL config at: $configPath", 'INFO');

        return $configPath;
    }

    /**
     * Generate CSR and private key
     *
     * @return array ['csr' => string, 'private_key' => string]
     */
    public function generateCSR() {
        // IMPORTANT: PHP's openssl_csr_new() CANNOT add Subject Alternative Name (SAN) extensions
        // which are REQUIRED by ZATCA. We must use command-line OpenSSL with config file.
        // DO NOT use PHP extension - it creates incomplete CSR (984 bytes) without ZATCA fields.

        ZatcaPhase2Config::log('Forcing command-line OpenSSL for ZATCA CSR generation...', 'INFO');
        ZatcaPhase2Config::log('Reason: PHP openssl extension cannot add required SAN fields', 'INFO');

        // Go directly to command-line OpenSSL method
        return $this->generateCSRCommandLine();

        /* DISABLED: PHP extension method - creates incomplete CSR without SAN fields
        try {
            ZatcaPhase2Config::log('Generating CSR using PHP OpenSSL extension...', 'INFO');

            // Generate private key
            $this->privateKey = openssl_pkey_new($this->config);

            if (!$this->privateKey) {
                $error = openssl_error_string();
                ZatcaPhase2Config::log('PHP OpenSSL failed: ' . $error, 'WARNING');

                // Fallback to command-line OpenSSL
                return $this->generateCSRCommandLine();
            }

            // Prepare DN (Distinguished Name)
            $dn = $this->buildDN();

            // Generate CSR
            $this->csr = openssl_csr_new($dn, $this->privateKey, $this->config);

            if (!$this->csr) {
                $error = openssl_error_string();
                ZatcaPhase2Config::log('CSR creation failed: ' . $error, 'WARNING');

                // Fallback to command-line OpenSSL
                return $this->generateCSRCommandLine();
            }

            // Export CSR
            if (!openssl_csr_export($this->csr, $csrString)) {
                throw new Exception('Failed to export CSR: ' . openssl_error_string());
            }

            // Export private key
            if (!openssl_pkey_export($this->privateKey, $privateKeyString, null, $this->config)) {
                throw new Exception('Failed to export private key: ' . openssl_error_string());
            }

            ZatcaPhase2Config::log('CSR generated successfully using PHP OpenSSL', 'INFO');

            return [
                'success' => true,
                'csr' => $csrString,
                'private_key' => $privateKeyString,
                'method' => 'php_extension'
            ];

        } catch (Exception $e) {
            $error = 'CSR generation error: ' . $e->getMessage();
            ZatcaPhase2Config::log($error, 'ERROR');

            // Try command-line fallback
            ZatcaPhase2Config::log('Attempting command-line OpenSSL fallback...', 'INFO');
            return $this->generateCSRCommandLine();
        }
        */
    }

    /**
     * Generate CSR using command-line OpenSSL (fallback method)
     *
     * @return array ['success' => bool, 'csr' => string, 'private_key' => string]
     */
    private function generateCSRCommandLine() {
        try {
            require_once __DIR__ . '/OpenSSLCommandLine.php';

            $cmdLine = new OpenSSLCommandLine();

            // Generate CSR
            $result = $cmdLine->generateCSR();

            if (!$result['success']) {
                return $result;
            }

            // Read the generated files
            $privateKey = file_get_contents($result['key_path']);

            ZatcaPhase2Config::log('CSR generated successfully using command-line OpenSSL', 'INFO');

            return [
                'success' => true,
                'csr' => $result['csr'],
                'private_key' => $privateKey,
                'method' => 'command_line'
            ];

        } catch (Exception $e) {
            return [
                'success' => false,
                'error' => 'Both PHP extension and command-line OpenSSL failed: ' . $e->getMessage()
            ];
        }
    }

    /**
     * Build Distinguished Name for CSR
     *
     * @return array DN array
     */
    private function buildDN() {
        // ZATCA requires specific OIDs in the certificate
        $dn = [
            'C' => ZatcaPhase2Config::$CERT_COUNTRY,
            'OU' => ZatcaPhase2Config::$CERT_ORGANIZATIONAL_UNIT,
            'O' => ZatcaPhase2Config::$CERT_ORGANIZATION_NAME,
            'CN' => ZatcaPhase2Config::$CERT_COMMON_NAME
        ];

        // Add custom OIDs for ZATCA
        // These are added as extensions in the actual implementation

        return $dn;
    }

    /**
     * Generate CSR with ZATCA-specific extensions
     *
     * @return array ['csr' => string, 'private_key' => string]
     */
    public function generateZatcaCSR() {
        try {
            // Generate basic CSR first
            $result = $this->generateCSR();

            if (!$result['success']) {
                return $result;
            }

            // Add ZATCA-specific OID extensions
            // Note: This requires manual CSR modification or using openssl command line
            // For production, use: openssl req -new -key private.key -out certificate.csr -config zatca.cnf

            $csrWithExtensions = $this->addZatcaExtensions($result['csr']);

            return [
                'success' => true,
                'csr' => $csrWithExtensions,
                'private_key' => $result['private_key']
            ];

        } catch (Exception $e) {
            $error = 'ZATCA CSR generation error: ' . $e->getMessage();
            ZatcaPhase2Config::log($error, 'ERROR');

            return [
                'success' => false,
                'error' => $error
            ];
        }
    }

    /**
     * Add ZATCA-specific extensions to CSR
     *
     * @param string $csr Original CSR
     * @return string Modified CSR
     */
    private function addZatcaExtensions($csr) {
        // ZATCA requires these OIDs:
        // 2.5.4.4 (SN) = Solution Name
        // 1.2.840.113549.1.9.2 (UID) = VAT Registration Number
        // 2.5.4.15 (businessCategory) = Industry
        // 1.3.6.1.4.1.311.60.2.1.3 (jurisdictionOfIncorporationCountryName) = SA

        // For now, return original CSR
        // In production, use OpenSSL config file or command line
        return $csr;
    }

    /**
     * Save CSR and private key to files
     *
     * @param string $csrPath Path to save CSR
     * @param string $keyPath Path to save private key
     * @return bool Success
     */
    public function saveToFiles($csrPath = null, $keyPath = null) {
        try {
            // Ensure certificate directory exists
            $certDir = ZatcaPhase2Config::CERT_DIR;
            if (!file_exists($certDir)) {
                if (!mkdir($certDir, 0700, true)) {
                    throw new Exception('Failed to create certificate directory: ' . $certDir);
                }
                ZatcaPhase2Config::log('Certificate directory created: ' . $certDir, 'INFO');
            }

            // Check if directory is writable
            if (!is_writable($certDir)) {
                throw new Exception('Certificate directory is not writable: ' . $certDir . '. Please run: chmod 700 ' . $certDir);
            }

            $result = $this->generateCSR();

            if (!$result['success']) {
                throw new Exception($result['error']);
            }

            $csrPath = $csrPath ?? ZatcaPhase2Config::CSR_FILE;
            $keyPath = $keyPath ?? ZatcaPhase2Config::PRIVATE_KEY_FILE;

            // Save CSR
            if (file_put_contents($csrPath, $result['csr']) === false) {
                throw new Exception('Failed to write CSR file: ' . $csrPath);
            }
            ZatcaPhase2Config::log('CSR saved to: ' . $csrPath, 'INFO');

            // Save private key with restricted permissions
            file_put_contents($keyPath, $result['private_key']);
            chmod($keyPath, 0600);
            ZatcaPhase2Config::log('Private key saved to: ' . $keyPath, 'INFO');

            return true;

        } catch (Exception $e) {
            ZatcaPhase2Config::log('Save error: ' . $e->getMessage(), 'ERROR');
            return false;
        }
    }

    /**
     * Get CSR in base64 format (for API submission)
     *
     * @return string Base64 encoded CSR
     */
    public function getCSRBase64() {
        if (!$this->csr) {
            $result = $this->generateCSR();
            if (!$result['success']) {
                return null;
            }
        }

        openssl_csr_export($this->csr, $csrString);

        // Remove headers and encode
        $csr = str_replace('-----BEGIN CERTIFICATE REQUEST-----', '', $csrString);
        $csr = str_replace('-----END CERTIFICATE REQUEST-----', '', $csr);
        $csr = str_replace("\n", '', $csr);
        $csr = str_replace("\r", '', $csr);

        return trim($csr);
    }

    /**
     * Generate OpenSSL config file for ZATCA CSR
     *
     * @param string $configPath Path to save config
     * @return bool Success
     */
    public function generateOpenSSLConfig($configPath = null) {
        $configPath = $configPath ?? ZatcaPhase2Config::CERT_DIR . '/zatca_openssl.cnf';

        $country = ZatcaPhase2Config::$CERT_COUNTRY;
        $orgUnit = ZatcaPhase2Config::$CERT_ORGANIZATIONAL_UNIT;
        $orgName = ZatcaPhase2Config::$CERT_ORGANIZATION_NAME;
        $commonName = ZatcaPhase2Config::$CERT_COMMON_NAME;
        $serialNumber = ZatcaPhase2Config::$CERT_SERIAL_NUMBER;
        $orgIdentifier = ZatcaPhase2Config::$CERT_ORGANIZATION_IDENTIFIER;
        $invoiceType = ZatcaPhase2Config::$CERT_INVOICE_TYPE;
        $location = ZatcaPhase2Config::$CERT_LOCATION;
        $industry = ZatcaPhase2Config::$CERT_INDUSTRY;

        $config = <<<EOT
[req]
default_bits = 2048
emailAddress = admin@company.com
req_extensions = v3_req
x509_extensions = v3_ca
prompt = no
default_md = sha256
req_extensions = req_ext
distinguished_name = dn

[dn]
C = $country
OU = $orgUnit
O = $orgName
CN = $commonName

[req_ext]
certificatePolicies = 1.3.6.1.4.1.311.21.8.8854730.1.1.1
subjectAltName = dirName:alt_names

[alt_names]
C = SA
serialNumber = $serialNumber
UID = $orgIdentifier
title = $invoiceType
registeredAddress = $location
businessCategory = $industry

[v3_req]
basicConstraints = CA:FALSE
keyUsage = digitalSignature, nonRepudiation, keyEncipherment

EOT;

        file_put_contents($configPath, $config);
        ZatcaPhase2Config::log('OpenSSL config saved to: ' . $configPath, 'INFO');

        return true;
    }
}

?>
